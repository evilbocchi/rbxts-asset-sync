import crypto from "crypto";
import fs from "fs";
import path from "path";
import { uploadAsset } from "./api.js";
import { assetMapOutputPath, cacheOutputPath, prefix, searchPath } from "./parameters.js";

/**
 * Cache mapping file hashes to Roblox asset IDs to avoid re-uploading identical files.
 */
let hashToAssetIdMap: Record<string, string> = {};

/**
 * Mapping of file paths to their corresponding Roblox asset IDs.
 * Used to generate the final asset map for TypeScript consumption.
 */
const pathToAssetIdMap: Record<string, string> = {};

// Load existing cache if it exists
if (fs.existsSync(cacheOutputPath)) {
    hashToAssetIdMap = JSON.parse(fs.readFileSync(cacheOutputPath, "utf8"));
}

/**
 * Saves the hash-to-asset-ID cache to disk for future runs.
 * This prevents re-uploading files that haven't changed.
 * 
 * @param verbose - Whether to log the cache save operation (default: true)
 */
async function saveCache(verbose = true) {
    await fs.promises.writeFile(cacheOutputPath, JSON.stringify(hashToAssetIdMap, null, 2));
    if (verbose) {
        console.log(`${prefix} Cache saved to ${cacheOutputPath}`);
    }
}

/**
 * Generates and saves a TypeScript asset map file containing all synced assets.
 * Creates a strongly-typed object mapping file paths to rbxassetid URLs.
 * 
 * @param verbose - Whether to log the generation summary (default: true)
 */
async function saveAssetMap(verbose = true) {
    const lines: string[] = [
        "// Auto-generated by rbx-asset-sync. Do not edit manually.",
        "export const assets = {"
    ];

    for (const [filePath, assetId] of Object.entries(pathToAssetIdMap)) {
        const normalizedPath = filePath.replace(/\\/g, "/");
        lines.push(`  \"${normalizedPath}\": \"rbxassetid://${assetId}\",`);
    }

    lines.push("} as const;\n");
    lines.push("export function getAsset(path: keyof typeof assets): string {\n  return assets[path];\n}");

    await fs.promises.writeFile(assetMapOutputPath, lines.join("\n"));
    if (verbose) {
        console.log(`${prefix} Asset map generated with ${Object.keys(pathToAssetIdMap).length} entries.`);
    }
}

/**
 * Saves both the cache and asset map to disk.
 * This is called after all assets have been processed to ensure everything is up-to-date.
 * 
 * @param verbose - Whether to log the save operations (default: true)
 */
export async function save(verbose = true): Promise<void> {
    await Promise.all([
        saveCache(verbose),
        saveAssetMap(verbose)
    ]);
}

/**
 * Synchronizes all asset files in the watching directory once.
 * This is the main entry point for batch synchronization.
 * 
 * @param verbose - Whether to log detailed output (default: true)
 * @returns Promise that resolves when all assets have been processed
 */
export async function syncAssetsOnce(verbose = true): Promise<void> {
    const files = getAllAssetFiles(searchPath);
    for (const file of files) {
        await syncAssetFile(file, verbose);
    }
    await save(verbose);
}

/**
 * Synchronizes a single asset file to Roblox.
 * Checks cache first to avoid re-uploading identical files, then uploads if needed.
 * 
 * @param filePath - Absolute path to the asset file to sync
 * @param verbose - Whether to log detailed output (default: true)
 * @returns Promise that resolves when the file has been processed
 * 
 * @example
 * ```typescript
 * await syncAssetFile("C:/project/assets/image.png");
 * ```
 */
export async function syncAssetFile(filePath: string, verbose = true): Promise<void> {
    const assetBuffer = fs.readFileSync(filePath);
    const assetName = path.basename(filePath);
    const hash = crypto.createHash("sha1").update(assetBuffer).digest("hex");

    if (hash in hashToAssetIdMap) {
        const assetId = hashToAssetIdMap[hash];
        if (verbose) {
            console.log(`${prefix} ${filePath} reused rbxassetid://${assetId}`);
        }
        pathToAssetIdMap[filePath] = assetId;
        return;
    }

    try {
        const assetId = await uploadAsset(assetName, assetBuffer);
        if (!assetId) {
            if (verbose) {
                console.warn(`${prefix} Skipping ${filePath} due to unsupported file type.`);
            }
            return;
        }

        if (verbose) {
            console.log(`${prefix} Uploaded ${filePath} -> rbxassetid://${assetId}`);
        }

        hashToAssetIdMap[hash] = assetId;
        pathToAssetIdMap[filePath] = assetId;
    } catch (err) {
        console.error(`${prefix} Failed to upload ${filePath}:`, err);
    }
}

/**
 * Recursively walks a directory tree and returns all file paths.
 * Used to discover all asset files that need to be synchronized.
 * 
 * @param watchingPath - Root directory path to scan for asset files
 * @returns Array of absolute file paths found in the directory tree
 * 
 * @example
 * ```typescript
 * const files = getAllAssetFiles("C:/project/assets");
 * // Returns: ["C:/project/assets/image.png", "C:/project/assets/sounds/audio.mp3"]
 * ```
 */
export function getAllAssetFiles(watchingPath: string): string[] {
    /**
     * Recursively walks a directory and collects all file paths.
     * 
     * @param dir - Directory path to walk
     * @returns Array of file paths in the directory
     */
    const walk = (dir: string): string[] => {
        let results: string[] = [];
        const list = fs.readdirSync(dir);
        for (const file of list) {
            const filePath = path.join(dir, file);
            const stat = fs.statSync(filePath);
            if (stat && stat.isDirectory()) {
                results = results.concat(walk(filePath));
            } else {
                results.push(filePath);
            }
        }
        return results;
    };

    return walk(watchingPath);
}

/**
 * Unlinks an asset file from the asset map.
 * This is called when a file is deleted or removed from the watching directory.
 * 
 * @param filePath - Absolute path to the asset file to unlink
 */
export function unlinkAssetFile(filePath: string): void {
    delete pathToAssetIdMap[filePath];
}

/**
 * Finds unused asset IDs in the cache and removes them.
 */
export function cleanCache() {
    const usedAssetIds = new Set(Object.values(pathToAssetIdMap));
    const unusedHashes = Object.keys(hashToAssetIdMap).filter(hash => !usedAssetIds.has(hashToAssetIdMap[hash]));

    for (const hash of unusedHashes) {
        delete hashToAssetIdMap[hash];
    }

    if (unusedHashes.length > 0) {
        console.log(`${prefix} Cleaned up ${unusedHashes.length} unused asset IDs from cache.`);
    } else {
        console.log(`${prefix} No unused asset IDs found in cache.`);
    }
}